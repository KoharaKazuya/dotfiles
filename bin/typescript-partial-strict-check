#!/usr/bin/env node

const path = require("path");
const fs = require("fs").promises;
const { spawn } = require("child_process");

async function main() {
  const targetFiles = await getTargetFiles();
  const roots = await getTypescriptRootDirectories(targetFiles);

  let code = 0;

  for (const root of roots) {
    const tsconfig = await parseTsConfigJson(root);
    if (tsconfig.compilerOptions.strict) continue;

    const tsc = spawn(
      "npx",
      [
        "--no-install",
        "tsc",
        "--strict",
        "--noEmit",
      ],
      { cwd: root }
    );

    const { filter, close, result } = createTscOutputFilter(root, targetFiles);
    tsc.stdout.on("data", filter);
    tsc.stdout.on("close", close);
    tsc.stderr.on("data", filter);
    tsc.stderr.on("close", close);
    await new Promise((resolve) => tsc.on("exit", resolve));

    if (!result.pass) code = 1;
  }

  process.exit(code);
}
main().catch((e) => {
  console.error(e);
  process.exit(1);
});

/**
 * @returns {Promise<string[]>}
 */
async function getTargetFiles() {
  let args = process.argv.slice(2);
  if (args.length > 0) return args;

  let data = "";
  for await (const chunk of process.stdin) {
    data += chunk;
  }

  const parts = data.split(/(\r?\n)/);
  let lines = [];
  for (let i = 0; i < parts.length; i += 2) {
    if (parts[i]) lines.push(parts[i]);
  }

  return lines;
}

/**
 * @param {string[]} targets
 * @returns {Promise<string[]>}
 */
async function getTypescriptRootDirectories(targets) {
  targets = targets.map((t) => path.resolve(t));

  const roots = [];

  let target;
  while ((target = targets.shift())) {
    let root = path.dirname(target);
    while (true) {
      try {
        await fs.access(path.join(root, "tsconfig.json"));
        roots.push(root);
        targets = targets.filter((t) => !t.startsWith(root));
        break;
      } catch (_) {}

      if (root === "/") break;
      root = path.dirname(root);
    }
  }

  return roots;
}

/**
 * @param {string} dir
 * @returns {object}
 */
async function parseTsConfigJson(dir) {
  const p = path.join(dir, "tsconfig.json");
  const data = await fs.readFile(p, { encoding: "utf-8" });
  const obj = JSON.parse(
    data.replace(/\/\/.*$/g, "").replace(/\/\*.*\*\//gm, "")
  );
  return obj;
}

/**
 * @param {string} root
 * @param {string[]} targets
 */
function createTscOutputFilter(root, targets) {
  targets = targets
    .map((t) => path.resolve(t))
    .filter((t) => t.startsWith(root))
    .map((t) => path.relative(root, t));

  const result = { pass: true };
  const pushLine = (line) => {
    if (targets.some((t) => line.startsWith(t))) {
      if (result.pass)
        process.stderr.write(`[typescript-partial-strict-check]: ${root}\n`);
      process.stderr.write(`${line}\n`);
      result.pass = false;
    }
  };

  let buffer = "";
  const filter = (data) => {
    buffer += data;

    const parts = buffer.split(/(\r?\n)/);
    for (let i = 0; i < parts.length - 1; i += 2) {
      pushLine(parts[i]);
    }
    buffer = parts[parts.length - 1];
  };

  const close = () => {
    process.stderr.write(buffer);
  };

  return { filter, close, result };
}
